import {session, Telegraf, Markup} from 'telegraf';
import config from 'config';
import {message} from "telegraf/filters";
import {code} from "telegraf/format";
import {openai} from './services/openai.js';
import {escapeMarkdownV2} from "./utils/escaper.js";
import authMiddleware from "./middlewares/auth-middleware.js";
import mongoose from "mongoose";
import UserService from "./services/user-service.js";
import CompanyService from "./services/company-service.js";
import RequestService from "./services/request-service.js";
import ModelService from "./services/model-service.js";
import updateLastActivityMiddleware from "./middlewares/updateLastActivity-middleware.js";
import {escapeMarkdown} from "./utils/escapeMarkdownV2.js";


const AVAILABLE_MODELS = [
    {
        name: "OpenAI o1-preview",
        description: "–Ω–æ–≤–∞—è –º–æ–¥–µ–ª—å –¥–ª—è —Ä–µ—à–µ–Ω–∏—è —Å–∞–º—ã—Ö —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–¥–∞—á –ø—É—Ç–µ–º —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏–π. –ö–∞–∂–¥—ã–π –∑–∞–ø—Ä–æ—Å —Ä–∞—Å—Ö–æ–¥—É–µ—Ç 5 –≥–µ–Ω–µ—Ä–∞—Ü–∏–π",
        picture: "üçì"
    },
    {
        name: "OpenAI o1-mini",
        description: "–Ω–æ–≤–∞—è –º–æ–¥–µ–ª—å –¥–ª—è –∫–æ–¥–∞, –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∏ –Ω–∞—É—á–Ω—ã—Ö –∑–∞–¥–∞—á",
        picture: "ü§ñ"
    },
    {
        name: "gpt-4o",
        description: "—É–º–Ω–∞—è –∏ –±—ã—Å—Ç—Ä–∞—è –º–æ–¥–µ–ª—å OpenAI –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Ç–µ–∫—Å—Ç–∞–º–∏",
        picture: "üî•"
    },
    {
        name: "gpt-4o mini",
        description: "–±—ã—Å—Ç—Ä–∞—è –∏ –¥–æ—Å—Ç—É–ø–Ω–∞—è –º–æ–¥–µ–ª—å OpenAI –¥–ª—è –ø–æ–≤—Å–µ–¥–Ω–µ–≤–Ω—ã—Ö –∑–∞–¥–∞—á",
        picture: "‚úîÔ∏è"
    },
]

const REGISTER_FORMAT = '\n—Ä–æ–ª—å\nid —Ç–µ–ª–µ–≥—Ä–∞–º–º –∞–∫–∫–∞—É–Ω—Ç–∞'

const bot = new Telegraf(config.get('TG_BOT_TOKEN'));

bot.use(session());
bot.use(authMiddleware);
bot.use(updateLastActivityMiddleware);

bot.telegram.setMyCommands([
    {command: '/start', description: '–ù–∞—á–∞—Ç—å –æ–±—â–µ–Ω–∏–µ'},
    {command: '/register', description: '–ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è'},
    {command: '/model', description: '–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–æ–¥–µ–ª–∏ OpenAI'}
]);

bot.command('new', async (ctx, next) => {
    ctx.session = {
        messages: [],
        systemMessages: []
    };
    await ctx.reply('–ñ–¥—É –≤–∞—à–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è');
    next();
});

bot.command('start', async (ctx) => {
    ctx.session = {
        messages: [],
        systemMessages: []
    };
    await ctx.reply(config.get('WELCOME_MESSAGE'));

    // update tg username
    const tgId = ctx.from.id;
    const tgUsername = ctx.from.username;
    // check cache. if equals skip
    const updatedUser = await UserService.updateUserByTgId(tgId, {telegramUsername: tgUsername});
    console.log(updatedUser);
});

bot.command('register', async (ctx) => {
    ctx.session ??= {
        messages: [],
        systemMessages: []
    };
    ctx.session.systemMessages.push({type: 'register', data: ctx.message.text})

    const systemMessage = await ctx.reply(code(`–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è..`));
    setTimeout(() => {
        ctx.deleteMessage(systemMessage.message_id).catch((err) => console.log('–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è', err));
    }, 2500)
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ\n' + REGISTER_FORMAT,
        Markup.inlineKeyboard([
            [Markup.button.callback('–û—Ç–º–µ–Ω–∏—Ç—å', 'close')]
        ]))
});

bot.command('model', async (ctx) => {
    // const
    const currentModel = await UserService.getUserModel(ctx.from.id.toString());
    let welcomeMessage = `–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ ChatGPT!\n\n–ó–¥–µ—Å—å –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –º–æ–¥–µ–ª—å –ø–æ —Å–≤–æ–µ–º—É —É—Å–º–æ—Ç—Ä–µ–Ω–∏—é –¥–ª—è –±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–≥–æ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è.\n
–¢–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å: ${currentModel?.name}.\n\n–î–æ—Å—Ç—É–ø–Ω—ã–µ –º–æ–¥–µ–ª–∏:\n\n`;
    AVAILABLE_MODELS.forEach(model => {
        welcomeMessage += `${model.picture} ${model.name} ‚Äî ${model.description}.\n\n`
    })

    await ctx.reply(welcomeMessage,
        Markup.inlineKeyboard([
            [Markup.button.callback('–í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥—É—é –º–æ–¥–µ–ª—å', 'changeModel')],
            [Markup.button.callback('–ó–∞–∫—Ä—ã—Ç—å', 'close')],
        ]));
});

bot.action('changeModel', async (ctx) => {
    console.log(ctx.update.callback_query.message.text);

    const modelButtons = AVAILABLE_MODELS.map(model => {
        return [Markup.button.callback(model.name, `setModel_${model.name}`)]
    });

    await ctx.editMessageText(ctx.update.callback_query.message.text, Markup.inlineKeyboard(modelButtons));
    // await ctx.editMessageText(availableModels);
});

bot.action(/setModel_(.+)/, async (ctx) => {
   const selectedModel = ctx.match[1].replace("OpenAI", "").trim();

   // await ctx.editMessageText(`–í—ã –≤—ã–±—Ä–∞–ª–∏ –º–æ–¥–µ–ª—å: ${selectedModel}`);
   const response = await UserService.setUserModel(ctx.from.id.toString(), selectedModel);

   if (response) {
       await ctx.editMessageText(`–£—Å–ø–µ—à–Ω–æ! –í—ã –≤—ã–±—Ä–∞–ª–∏ –º–æ–¥–µ–ª—å: ${selectedModel}.`);
   } else {
       await ctx.editMessageText(`Something wrong..`);
   }
   // console.log(response);
});

bot.action('close', async (ctx) => {
    ctx.session.systemMessages = [];
    await ctx.editMessageReplyMarkup();
    await ctx.editMessageText("–î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ.");
});

function splitMessage(text, maxLength = 4096) {
    const messages = [];
    let current = '';
    let inCodeBlock = false; // –§–ª–∞–≥ –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–ª–æ–∫–∞ –∫–æ–¥–∞

    // –†–∞–∑–¥–µ–ª—è–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ —Å—Ç—Ä–æ–∫–∏ –¥–ª—è –±–æ–ª–µ–µ –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ —Ä–∞–∑–±–∏–µ–Ω–∏—è
    const lines = text.split('\n');

    for (let line of lines) {
        const codeBlockRegex = /^```/; // –†–µ–≥—É–ª—è—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è –Ω–∞—á–∞–ª–∞/–∫–æ–Ω—Ü–∞ –±–ª–æ–∫–∞ –∫–æ–¥–∞

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ç–µ–∫—É—â–∞—è —Å—Ç—Ä–æ–∫–∞ –Ω–∞—á–∞–ª–æ–º –∏–ª–∏ –∫–æ–Ω—Ü–æ–º –±–ª–æ–∫–∞ –∫–æ–¥–∞
        if (codeBlockRegex.test(line.trim())) {
            inCodeBlock = !inCodeBlock;
        }

        // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º, —á—Ç–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏ –Ω–µ –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ª–∏–º–∏—Ç
        let addedLength = line.length + 1; // +1 –¥–ª—è —Å–∏–º–≤–æ–ª–∞ –ø–µ—Ä–µ–Ω–æ—Å–∞ —Å—Ç—Ä–æ–∫–∏

        // –ï—Å–ª–∏ —Ç–µ–∫—É—â–∏–π —Ç–µ–∫—Å—Ç –Ω–µ –ø—É—Å—Ç–æ–π, —É—á–∏—Ç—ã–≤–∞–µ–º —Å–∏–º–≤–æ–ª –ø–µ—Ä–µ–Ω–æ—Å–∞ —Å—Ç—Ä–æ–∫–∏
        if (current.length > 0) {
            addedLength = line.length + 1; // '\n' + line
        } else {
            addedLength = line.length;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ª–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–∏ –ª–∏–º–∏—Ç
        if ((current.length + addedLength) > maxLength) {
            // –ï—Å–ª–∏ –º—ã –Ω–∞—Ö–æ–¥–∏–º—Å—è –≤–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞ –∫–æ–¥–∞, –Ω–∞–º –Ω—É–∂–Ω–æ –∑–∞–∫—Ä—ã—Ç—å –µ–≥–æ –ø–µ—Ä–µ–¥ —Ä–∞–∑–±–∏–µ–Ω–∏–µ–º
            if (inCodeBlock) {
                current += '\n```'; // –ó–∞–∫—Ä—ã–≤–∞–µ–º –±–ª–æ–∫ –∫–æ–¥–∞
                messages.push(current);
                current = '```'; // –û—Ç–∫—Ä—ã–≤–∞–µ–º –Ω–æ–≤—ã–π –±–ª–æ–∫ –∫–æ–¥–∞ –≤ —Å–ª–µ–¥—É—é—â–µ–º —Å–æ–æ–±—â–µ–Ω–∏–∏
            } else {
                // –ï—Å–ª–∏ –Ω–µ –≤–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞ –∫–æ–¥–∞, –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
                if (current.length > 0) {
                    messages.push(current);
                    current = '';
                }
            }

            // –ï—Å–ª–∏ —Å—Ç—Ä–æ–∫–∞ —Å–∞–º–∞ –ø–æ —Å–µ–±–µ –¥–ª–∏–Ω–Ω–µ–µ –ª–∏–º–∏—Ç–∞, –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –µ—ë –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–∑–±–∏—Ç—å
            while (line.length > maxLength) {
                const part = line.substring(0, maxLength);
                messages.push(part);
                line = line.substring(maxLength);
            }
        }

        // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–æ–∫—É –∫ —Ç–µ–∫—É—â–µ–º—É —Å–æ–æ–±—â–µ–Ω–∏—é —Å —É—á—ë—Ç–æ–º –ø–µ—Ä–µ–Ω–æ—Å–∞ —Å—Ç—Ä–æ–∫–∏
        current += (current.length > 0 ? '\n' : '') + line;
    }

    // –ï—Å–ª–∏ –ø–æ—Å–ª–µ —Ü–∏–∫–ª–∞ –æ—Å—Ç–∞–ª—Å—è —Ç–µ–∫—Å—Ç, –¥–æ–±–∞–≤–ª—è–µ–º –µ–≥–æ –≤ —Å–æ–æ–±—â–µ–Ω–∏—è
    if (current.length > 0) {
        // –ï—Å–ª–∏ –º—ã –Ω–∞—Ö–æ–¥–∏–º—Å—è –≤–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞ –∫–æ–¥–∞, –∑–∞–∫—Ä—ã–≤–∞–µ–º –µ–≥–æ
        if (inCodeBlock) {
            current += '\n```';
        }
        messages.push(current);
    }

    return messages;
}

async function register(ctx) {
    const inputDataArr = ctx.message.text.split('\n');
    const data = {
        roleName: inputDataArr[0],
        companyName: await CompanyService.getCompanyNameByUserTgId(ctx.from.id.toString()),
        telegramId: inputDataArr[1]
    }

    ctx.session.systemMessages.push({type: 'registerConfirm', data})
    const newUserText = `–†–æ–ª—å: ${data.roleName}\n–ù–∞–∑–≤–∞–Ω–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏: ${data.companyName}\n–¢–µ–ª–µ–≥—Ä–∞–º–º id: ${data.telegramId}`;


    await ctx.reply(`–í—ã —Ö–æ—Ç–∏—Ç–µ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è?\n\n${newUserText}`,
        Markup.inlineKeyboard([
            [Markup.button.callback('–î–∞', 'register')],
            [Markup.button.callback('–ù–µ—Ç..', 'registerCancel')]
        ]));
    // ctx.session.messages.pop(); // –æ—á–∏—Å—Ç–∫–∞ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
}

bot.on(message('text'), async (ctx) => {
    ctx.session ??= {
        messages: [],
        systemMessages: []
    };
    try {
        // console.log(ctx.from);
        const lastSystemMessage = ctx.session.systemMessages[ctx.session.systemMessages.length - 1];
        if (lastSystemMessage?.type === 'register') { // type?
            await register(ctx);
            return;
        }

        await ctx.reply(code('–°–æ–æ–±—â–µ–Ω–∏–µ –ø—Ä–∏–Ω—è–ª. –ñ–¥—É –æ—Ç–≤–µ—Ç –æ—Ç —Å–µ—Ä–≤–µ—Ä–∞...'));
        // await ctx.reply(code(`–í–∞—à –∑–∞–ø—Ä–æ—Å: ${ctx.message.text}`))
        // await ctx.reply(JSON.stringify(ctx.message, null, 2));
        ctx.session.messages.push({role: openai.roles.USER, content: ctx.message.text})
        // const messages = [{role: openai.roles.USER, content: ctx.message.text}];
        // await ctx.reply(JSON.stringify(ctx.session, null, 2));

        const model = await UserService.getUserModel(ctx.from.id.toString());
        // console.log('request with model ', model)
        const response = await openai.chat(ctx.session.messages, model.name);

        ctx.session.messages.push({role: openai.roles.ASSISTANT, content: response.content})

        // const text = escapeMarkdownV2(response.content);
        // console.log(text.length);

        const splittedText = splitMessage(response.content, 4096);
        for await (const chunk of splittedText) {
            await ctx.reply(chunk, {parse_mode: "Markdown"});
        }

        // –≠–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ MarkdownV2
        // const escapedText = escapeMarkdown(response.content);

        // –†–∞–∑–±–∏–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –Ω–∞ —á–∞—Å—Ç–∏
        // const messages = splitMessage(text, 4096);

        // –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π —Å —É—á–µ—Ç–æ–º MarkdownV2 –∏ –∑–∞–¥–µ—Ä–∂–∫–æ–π
        // await sendMessages(ctx, messages, 'MarkdownV2');

        const user = await UserService.getUserByTgId(ctx.from.id.toString());
        // const model = await ModelService.getModelById(user.modelId);
        const request = await RequestService.create(
            model.name,
            ctx.message.text,
            response.content,
            response.tokens.promptTokens,
            response.tokens.completionTokens,
            response.tokens.totalTokens,
            (response.tokens.promptTokens * model.inputPrice) + (response.tokens.completionTokens * model.outputPrice)
        );
        // console.log(request);

    } catch (e) {
        console.log('Error from text message', e)
    }
});

bot.action('register', async (ctx) => {
    try {
        await ctx.editMessageReplyMarkup();
        await ctx.reply('–ü—Ä–æ—Ü–µ—Å—Å —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏ –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è..');

        const userData = ctx.session.systemMessages.pop().data;
        const response = await UserService.register(userData.roleName, userData.companyName, userData.telegramId);

        await ctx.reply(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω!`)
        ctx.session.systemMessages = [];

    } catch (e) {
        console.log('Error from register action', e);
        await ctx.reply('–û—Ç–∫–∞–∑–∞–Ω–æ!\n' + e);
    }
});

bot.action('registerCancel', async (ctx) => {
    await ctx.editMessageReplyMarkup();
    await ctx.editMessageText('–û—Ç–º–µ–Ω–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏..')

    setTimeout(async () => {
        await ctx.editMessageText('–û—Ç–º–µ–Ω–µ–Ω–æ.');
    }, 1200)

    ctx.session.systemMessages = [];
});

const start = async () => {
    await mongoose.connect(config.get("MONGO_URI"), {
        useNewUrlParser: true,
        useUnifiedTopology: true
    }).then(() => {
        console.log('Successfully connected to MongoDB');
    }).catch(err => {
        console.error('Error connecting to MongoDB', err);
    })

    bot.launch();
}

start();

process.once('SIGINT', () => bot.stop('SIGINT'));
process.once('SIGTERM', () => bot.stop('SIGTERM'));